"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/redux/actions.js":
/*!******************************!*\
  !*** ./src/redux/actions.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ADD_ITEM: () => (/* binding */ ADD_ITEM),\n/* harmony export */   ADD_PURCHASE_LOG: () => (/* binding */ ADD_PURCHASE_LOG),\n/* harmony export */   ADD_USAGE: () => (/* binding */ ADD_USAGE),\n/* harmony export */   API_ERROR: () => (/* binding */ API_ERROR),\n/* harmony export */   DELETE_ITEM: () => (/* binding */ DELETE_ITEM),\n/* harmony export */   FETCH_ITEMS: () => (/* binding */ FETCH_ITEMS),\n/* harmony export */   FETCH_PURCHASE_LOGS: () => (/* binding */ FETCH_PURCHASE_LOGS),\n/* harmony export */   HANDLE_API_ERROR: () => (/* binding */ HANDLE_API_ERROR),\n/* harmony export */   UPDATE_ITEM: () => (/* binding */ UPDATE_ITEM),\n/* harmony export */   addItem: () => (/* binding */ addItem),\n/* harmony export */   addPurchaseLog: () => (/* binding */ addPurchaseLog),\n/* harmony export */   addUsage: () => (/* binding */ addUsage),\n/* harmony export */   deleteItem: () => (/* binding */ deleteItem),\n/* harmony export */   fetchItems: () => (/* binding */ fetchItems),\n/* harmony export */   fetchPurchaseLogs: () => (/* binding */ fetchPurchaseLogs),\n/* harmony export */   fetchUsage: () => (/* binding */ fetchUsage)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(pages-dir-browser)/./node_modules/axios/index.js\");\n\n// Action Types\nconst ADD_ITEM = 'ADD_ITEM';\nconst UPDATE_ITEM = 'UPDATE_ITEM';\nconst DELETE_ITEM = 'DELETE_ITEM';\nconst FETCH_ITEMS = 'FETCH_ITEMS';\nconst FETCH_PURCHASE_LOGS = 'FETCH_PURCHASE_LOGS';\nconst HANDLE_API_ERROR = 'HANDLE_API_ERROR';\nconst ADD_PURCHASE_LOG = 'ADD_PURCHASE_LOG';\nconst API_ERROR = 'API_ERROR';\nconst ADD_USAGE = 'ADD_USAGE';\n// Configure Axios instance with defaults\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: \"http://localhost:5000/api\" || 0,\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    validateStatus: function(status) {\n        return status < 500; // Don't throw for 4xx errors\n    }\n});\n// Helper function to handle API errors\nconst handleApiError = (error, dispatch1, actionType)=>{\n    var _error_response, _error_response1;\n    const errorData = {\n        message: error.message,\n        status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n        data: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.data,\n        actionType\n    };\n    console.error(\"API Error in \".concat(actionType, \":\"), errorData);\n    dispatch1({\n        type: API_ERROR,\n        payload: errorData\n    });\n    return errorData;\n};\n// Action Creators\n// Add Item Action\nconst addItem = (item)=>async (dispatch1)=>{\n        try {\n            if (!item.name || !item.category) {\n                throw new Error('Name and category are required');\n            }\n            const payload = {\n                name: item.name.trim(),\n                category: item.category.trim(),\n                initialStock: Math.max(0, Number(item.initialStock)) || 0,\n                purchased: Math.max(0, Number(item.purchased)) || 0,\n                used: Math.max(0, Number(item.used)) || 0\n            };\n            console.log('Adding item:', payload);\n            const response = await api.post('/inventory', payload);\n            dispatch1({\n                type: ADD_ITEM,\n                payload: response.data\n            });\n            return response.data;\n        } catch (error) {\n            return handleApiError(error, dispatch1, ADD_ITEM);\n        }\n    };\n// Add Usage Action\nconst addUsage = (usageData)=>async (dispatch1)=>{\n        try {\n            var _usageData_itemName, _usageData_category;\n            const payload = {\n                itemName: (_usageData_itemName = usageData.itemName) === null || _usageData_itemName === void 0 ? void 0 : _usageData_itemName.trim(),\n                category: (_usageData_category = usageData.category) === null || _usageData_category === void 0 ? void 0 : _usageData_category.trim(),\n                quantityUsed: Math.max(1, Number(usageData.quantityUsed)),\n                date: usageData.date || new Date().toISOString()\n            };\n            console.log('Adding usage:', payload);\n            const response = await api.post('/usage', payload);\n            dispatch1({\n                type: ADD_USAGE,\n                payload: response.data\n            });\n            return response.data;\n        } catch (error) {\n            return handleApiError(error, dispatch1, ADD_USAGE);\n        }\n    };\n// Update Item Action\napp.put('/api/inventory/:id', async (req, res)=>{\n    const { id } = req.params; // Extracts the id from the URL\n    const { name, category, initialStock, purchased, used } = req.body; // Extracts the updates from the request body\n    try {\n        // Logic to update the inventory item based on the `id`\n        const updatedItem = await Inventory.findByIdAndUpdate(id, {\n            name,\n            category,\n            initialStock,\n            purchased,\n            used\n        }, {\n            new: true\n        });\n        if (!updatedItem) {\n            return res.status(404).json({\n                message: 'Item not found'\n            });\n        }\n        // Return the updated item\n        res.json(updatedItem);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({\n            message: 'Error updating item'\n        });\n    }\n});\n// Delete Item Action\nconst deleteItem = (id)=>async (dispatch1)=>{\n        try {\n            console.log(\"Deleting item \".concat(id));\n            await api.delete(\"/inventory/\".concat(id));\n            dispatch1({\n                type: DELETE_ITEM,\n                payload: id\n            });\n            return {\n                success: true\n            };\n        } catch (error) {\n            return handleApiError(error, dispatch1, DELETE_ITEM);\n        }\n    };\n// Fetch Items Action\nconst fetchItems = ()=>async (dispatch1)=>{\n        try {\n            console.log('Fetching items');\n            const response = await api.get('/inventory');\n            dispatch1({\n                type: FETCH_ITEMS,\n                payload: response.data\n            });\n            return response.data;\n        } catch (error) {\n            return handleApiError(error, dispatch1, FETCH_ITEMS);\n        }\n    };\n// Fetch Purchase Logs Action\nconst fetchPurchaseLogs = ()=>async (dispatch1)=>{\n        try {\n            console.log('Fetching purchase logs');\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get('http://localhost:5000/api/purchases'); // Ensure correct backend URL\n            console.log(response.data); // Log the fetched data\n            dispatch1({\n                type: FETCH_PURCHASE_LOGS,\n                payload: response.data\n            });\n            return response.data;\n        } catch (error) {\n            console.error('Error fetching purchase logs:', error.message); // Log any error during fetching\n            dispatch1({\n                type: HANDLE_API_ERROR,\n                payload: error.message\n            });\n        }\n    };\n// Add Purchase Log Action\nconst addPurchaseLog = (purchaseData)=>async (dispatch1)=>{\n        try {\n            var _purchaseData_itemName, _purchaseData_category, _purchaseData_supplier;\n            const payload = {\n                itemName: (_purchaseData_itemName = purchaseData.itemName) === null || _purchaseData_itemName === void 0 ? void 0 : _purchaseData_itemName.trim(),\n                category: (_purchaseData_category = purchaseData.category) === null || _purchaseData_category === void 0 ? void 0 : _purchaseData_category.trim(),\n                quantity: Math.max(1, Number(purchaseData.quantity)),\n                unitPrice: Math.max(0, Number(purchaseData.unitPrice)) || 0,\n                totalCost: Math.max(0, Number(purchaseData.quantity) * Number(purchaseData.unitPrice || 1)),\n                date: purchaseData.date || new Date().toISOString(),\n                supplier: ((_purchaseData_supplier = purchaseData.supplier) === null || _purchaseData_supplier === void 0 ? void 0 : _purchaseData_supplier.trim()) || null\n            };\n            console.log('Adding purchase:', payload);\n            const response = await api.post('/purchases', payload);\n            // Dispatch two actions:\n            // 1. Add the new purchase to the log\n            dispatch1({\n                type: ADD_PURCHASE_LOG,\n                payload: response.data\n            });\n            // 2. Update the inventory item's purchased quantity\n            if (purchaseData.itemId) {\n                dispatch1({\n                    type: UPDATE_ITEM,\n                    payload: {\n                        id: purchaseData.itemId,\n                        updates: {\n                            purchased: response.data.newPurchaseTotal\n                        }\n                    }\n                });\n            }\n            return response.data;\n        } catch (error) {\n            return handleApiError(error, dispatch1, ADD_PURCHASE_LOG);\n        }\n    };\nconst fetchUsage = ()=>{\n    return async (dispatch1)=>{\n        try {\n            const response = await fetch('http://localhost:5000/api/usage');\n            const data = await response.json();\n            dispatch1({\n                type: 'FETCH_USAGE_SUCCESS',\n                payload: data\n            });\n        } catch (error) {\n            dispatch1({\n                type: 'FETCH_USAGE_FAILURE',\n                error: error.message\n            });\n        }\n    };\n};\nconsole.log('Selected Item:', selectedItem);\nif (selectedItem && selectedItem.id) {\n    await dispatch(updateItem(selectedItem.id, {\n        used: selectedItem.used + parseInt(formData.quantityUsed)\n    }));\n} else {\n    console.error('Selected item ID is undefined or invalid');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9yZWR1eC9hY3Rpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUUxQixlQUFlO0FBQ1IsTUFBTUMsV0FBVyxXQUFXO0FBQzVCLE1BQU1DLGNBQWMsY0FBYztBQUNsQyxNQUFNQyxjQUFjLGNBQWM7QUFDbEMsTUFBTUMsY0FBYyxjQUFjO0FBQ2xDLE1BQU1DLHNCQUFzQixzQkFBc0I7QUFDbEQsTUFBTUMsbUJBQW1CLG1CQUFtQjtBQUM1QyxNQUFNQyxtQkFBbUIsbUJBQW1CO0FBQzVDLE1BQU1DLFlBQVksWUFBWTtBQUM5QixNQUFNQyxZQUFZLFlBQVk7QUFFckMseUNBQXlDO0FBQ3pDLE1BQU1DLE1BQU1WLG9EQUFZLENBQUM7SUFDdkJZLFNBQVNDLDJCQUErQixJQUFJLENBQTJCO0lBQ3ZFRyxTQUFTO1FBQ1AsZ0JBQWdCO0lBQ2xCO0lBQ0FDLGdCQUFnQixTQUFVQyxNQUFNO1FBQzlCLE9BQU9BLFNBQVMsS0FBSyw2QkFBNkI7SUFDcEQ7QUFDRjtBQUVBLHVDQUF1QztBQUN2QyxNQUFNQyxpQkFBaUIsQ0FBQ0MsT0FBT0MsV0FBVUM7UUFHN0JGLGlCQUNGQTtJQUhSLE1BQU1HLFlBQVk7UUFDaEJDLFNBQVNKLE1BQU1JLE9BQU87UUFDdEJOLE1BQU0sR0FBRUUsa0JBQUFBLE1BQU1LLFFBQVEsY0FBZEwsc0NBQUFBLGdCQUFnQkYsTUFBTTtRQUM5QlEsSUFBSSxHQUFFTixtQkFBQUEsTUFBTUssUUFBUSxjQUFkTCx1Q0FBQUEsaUJBQWdCTSxJQUFJO1FBQzFCSjtJQUNGO0lBRUFLLFFBQVFQLEtBQUssQ0FBQyxnQkFBMkIsT0FBWEUsWUFBVyxNQUFJQztJQUU3Q0YsVUFBUztRQUNQTyxNQUFNcEI7UUFDTnFCLFNBQVNOO0lBQ1g7SUFFQSxPQUFPQTtBQUNUO0FBRUEsa0JBQWtCO0FBRWxCLGtCQUFrQjtBQUNYLE1BQU1PLFVBQVUsQ0FBQ0MsT0FBUyxPQUFPVjtRQUN0QyxJ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QU87WUFDZCxPQUFPRCxlQUFlQyxPQUFPQyxXQUFVZDtRQUN6QztJQUNGLEVBQUU7QUFFSyxNQUFNdUUsYUFBYTtJQUN4QixPQUFPLE9BQU96RDtRQUNaLElBQUk7WUFDRixNQUFNSSxXQUFXLE1BQU1zRCxNQUFNO1lBQzdCLE1BQU1yRCxPQUFPLE1BQU1ELFNBQVNxQyxJQUFJO1lBQ2hDekMsVUFBUztnQkFDUE8sTUFBTTtnQkFDTkMsU0FBU0g7WUFDWDtRQUNGLEVBQUUsT0FBT04sT0FBTztZQUNkQyxVQUFTO2dCQUFFTyxNQUFNO2dCQUF1QlIsT0FBT0EsTUFBTUksT0FBTztZQUFDO1FBRS9EO0lBQ0Y7QUFDRixFQUFFO0FBRUZHLFFBQVFlLEdBQUcsQ0FBQyxrQkFBa0JzQztBQUM5QixJQUFJQSxnQkFBZ0JBLGFBQWF6QixFQUFFLEVBQUU7SUFDbkMsTUFBTWxDLFNBQ0o0RCxXQUFXRCxhQUFhekIsRUFBRSxFQUFFO1FBQzFCZCxNQUFNdUMsYUFBYXZDLElBQUksR0FBR3lDLFNBQVNDLFNBQVNwQyxZQUFZO0lBQzFEO0FBRUosT0FBTztJQUNMcEIsUUFBUVAsS0FBSyxDQUFDO0FBQ2hCIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXEludmVudG9yeSBNYW5hZ2VtZW50IHN5c3RlbVxcZnJvbnRlbmRcXHNyY1xccmVkdXhcXGFjdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuXHJcbi8vIEFjdGlvbiBUeXBlc1xyXG5leHBvcnQgY29uc3QgQUREX0lURU0gPSAnQUREX0lURU0nO1xyXG5leHBvcnQgY29uc3QgVVBEQVRFX0lURU0gPSAnVVBEQVRFX0lURU0nO1xyXG5leHBvcnQgY29uc3QgREVMRVRFX0lURU0gPSAnREVMRVRFX0lURU0nO1xyXG5leHBvcnQgY29uc3QgRkVUQ0hfSVRFTVMgPSAnRkVUQ0hfSVRFTVMnO1xyXG5leHBvcnQgY29uc3QgRkVUQ0hfUFVSQ0hBU0VfTE9HUyA9ICdGRVRDSF9QVVJDSEFTRV9MT0dTJztcclxuZXhwb3J0IGNvbnN0IEhBTkRMRV9BUElfRVJST1IgPSAnSEFORExFX0FQSV9FUlJPUic7XHJcbmV4cG9ydCBjb25zdCBBRERfUFVSQ0hBU0VfTE9HID0gJ0FERF9QVVJDSEFTRV9MT0cnO1xyXG5leHBvcnQgY29uc3QgQVBJX0VSUk9SID0gJ0FQSV9FUlJPUic7XHJcbmV4cG9ydCBjb25zdCBBRERfVVNBR0UgPSAnQUREX1VTQUdFJztcclxuXHJcbi8vIENvbmZpZ3VyZSBBeGlvcyBpbnN0YW5jZSB3aXRoIGRlZmF1bHRzXHJcbmNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XHJcbiAgYmFzZVVSTDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo1MDAwL2FwaScsXHJcbiAgaGVhZGVyczoge1xyXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICB9LFxyXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiAoc3RhdHVzKSB7XHJcbiAgICByZXR1cm4gc3RhdHVzIDwgNTAwOyAvLyBEb24ndCB0aHJvdyBmb3IgNHh4IGVycm9yc1xyXG4gIH0sXHJcbn0pO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBBUEkgZXJyb3JzXHJcbmNvbnN0IGhhbmRsZUFwaUVycm9yID0gKGVycm9yLCBkaXNwYXRjaCwgYWN0aW9uVHlwZSkgPT4ge1xyXG4gIGNvbnN0IGVycm9yRGF0YSA9IHtcclxuICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlPy5zdGF0dXMsXHJcbiAgICBkYXRhOiBlcnJvci5yZXNwb25zZT8uZGF0YSxcclxuICAgIGFjdGlvblR5cGUsXHJcbiAgfTtcclxuXHJcbiAgY29uc29sZS5lcnJvcihgQVBJIEVycm9yIGluICR7YWN0aW9uVHlwZX06YCwgZXJyb3JEYXRhKTtcclxuXHJcbiAgZGlzcGF0Y2goe1xyXG4gICAgdHlwZTogQVBJX0VSUk9SLFxyXG4gICAgcGF5bG9hZDogZXJyb3JEYXRhLFxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gZXJyb3JEYXRhO1xyXG59O1xyXG5cclxuLy8gQWN0aW9uIENyZWF0b3JzXHJcblxyXG4vLyBBZGQgSXRlbSBBY3Rpb25cclxuZXhwb3J0IGNvbnN0IGFkZEl0ZW0gPSAoaXRlbSkgPT4gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghaXRlbS5uYW1lIHx8ICFpdGVtLmNhdGVnb3J5KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmFtZSBhbmQgY2F0ZWdvcnkgYXJlIHJlcXVpcmVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgbmFtZTogaXRlbS5uYW1lLnRyaW0oKSxcclxuICAgICAgY2F0ZWdvcnk6IGl0ZW0uY2F0ZWdvcnkudHJpbSgpLFxyXG4gICAgICBpbml0aWFsU3RvY2s6IE1hdGgubWF4KDAsIE51bWJlcihpdGVtLmluaXRpYWxTdG9jaykpIHx8IDAsXHJcbiAgICAgIHB1cmNoYXNlZDogTWF0aC5tYXgoMCwgTnVtYmVyKGl0ZW0ucHVyY2hhc2VkKSkgfHwgMCxcclxuICAgICAgdXNlZDogTWF0aC5tYXgoMCwgTnVtYmVyKGl0ZW0udXNlZCkpIHx8IDAsXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgaXRlbTonLCBwYXlsb2FkKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9pbnZlbnRvcnknLCBwYXlsb2FkKTtcclxuXHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6IEFERF9JVEVNLFxyXG4gICAgICBwYXlsb2FkOiByZXNwb25zZS5kYXRhLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiBoYW5kbGVBcGlFcnJvcihlcnJvciwgZGlzcGF0Y2gsIEFERF9JVEVNKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBBZGQgVXNhZ2UgQWN0aW9uXHJcbmV4cG9ydCBjb25zdCBhZGRVc2FnZSA9ICh1c2FnZURhdGEpID0+IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICBpdGVtTmFtZTogdXNhZ2VEYXRhLml0ZW1OYW1lPy50cmltKCksXHJcbiAgICAgIGNhdGVnb3J5OiB1c2FnZURhdGEuY2F0ZWdvcnk/LnRyaW0oKSxcclxuICAgICAgcXVhbnRpdHlVc2VkOiBNYXRoLm1heCgxLCBOdW1iZXIodXNhZ2VEYXRhLnF1YW50aXR5VXNlZCkpLFxyXG4gICAgICBkYXRlOiB1c2FnZURhdGEuZGF0ZSB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgdXNhZ2U6JywgcGF5bG9hZCk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvdXNhZ2UnLCBwYXlsb2FkKTtcclxuXHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6IEFERF9VU0FHRSxcclxuICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gaGFuZGxlQXBpRXJyb3IoZXJyb3IsIGRpc3BhdGNoLCBBRERfVVNBR0UpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSBJdGVtIEFjdGlvblxyXG5hcHAucHV0KCcvYXBpL2ludmVudG9yeS86aWQnLCBhc3luYyAocmVxLCByZXMpID0+IHtcclxuICBjb25zdCB7IGlkIH0gPSByZXEucGFyYW1zOyAvLyBFeHRyYWN0cyB0aGUgaWQgZnJvbSB0aGUgVVJMXHJcbiAgY29uc3QgeyBuYW1lLCBjYXRlZ29yeSwgaW5pdGlhbFN0b2NrLCBwdXJjaGFzZWQsIHVzZWQgfSA9IHJlcS5ib2R5OyAvLyBFeHRyYWN0cyB0aGUgdXBkYXRlcyBmcm9tIHRoZSByZXF1ZXN0IGJvZHlcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIExvZ2ljIHRvIHVwZGF0ZSB0aGUgaW52ZW50b3J5IGl0ZW0gYmFzZWQgb24gdGhlIGBpZGBcclxuICAgIGNvbnN0IHVwZGF0ZWRJdGVtID0gYXdhaXQgSW52ZW50b3J5LmZpbmRCeUlkQW5kVXBkYXRlKGlkLCB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGNhdGVnb3J5LFxyXG4gICAgICBpbml0aWFsU3RvY2ssXHJcbiAgICAgIHB1cmNoYXNlZCxcclxuICAgICAgdXNlZCxcclxuICAgIH0sIHsgbmV3OiB0cnVlIH0pO1xyXG5cclxuICAgIGlmICghdXBkYXRlZEl0ZW0pIHtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgbWVzc2FnZTogJ0l0ZW0gbm90IGZvdW5kJyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIHVwZGF0ZWQgaXRlbVxyXG4gICAgcmVzLmpzb24odXBkYXRlZEl0ZW0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgbWVzc2FnZTogJ0Vycm9yIHVwZGF0aW5nIGl0ZW0nIH0pO1xyXG4gIH1cclxufSk7XHJcblxyXG5cclxuLy8gRGVsZXRlIEl0ZW0gQWN0aW9uXHJcbmV4cG9ydCBjb25zdCBkZWxldGVJdGVtID0gKGlkKSA9PiBhc3luYyAoZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc29sZS5sb2coYERlbGV0aW5nIGl0ZW0gJHtpZH1gKTtcclxuICAgIGF3YWl0IGFwaS5kZWxldGUoYC9pbnZlbnRvcnkvJHtpZH1gKTtcclxuXHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6IERFTEVURV9JVEVNLFxyXG4gICAgICBwYXlsb2FkOiBpZCxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIGhhbmRsZUFwaUVycm9yKGVycm9yLCBkaXNwYXRjaCwgREVMRVRFX0lURU0pO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEZldGNoIEl0ZW1zIEFjdGlvblxyXG5leHBvcnQgY29uc3QgZmV0Y2hJdGVtcyA9ICgpID0+IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgaXRlbXMnKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdldCgnL2ludmVudG9yeScpO1xyXG5cclxuICAgIGRpc3BhdGNoKHtcclxuICAgICAgdHlwZTogRkVUQ0hfSVRFTVMsXHJcbiAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIGhhbmRsZUFwaUVycm9yKGVycm9yLCBkaXNwYXRjaCwgRkVUQ0hfSVRFTVMpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEZldGNoIFB1cmNoYXNlIExvZ3MgQWN0aW9uXHJcbmV4cG9ydCBjb25zdCBmZXRjaFB1cmNoYXNlTG9ncyA9ICgpID0+IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgcHVyY2hhc2UgbG9ncycpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoJ2h0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9hcGkvcHVyY2hhc2VzJyk7ICAvLyBFbnN1cmUgY29ycmVjdCBiYWNrZW5kIFVSTFxyXG5cclxuICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLmRhdGEpOyAvLyBMb2cgdGhlIGZldGNoZWQgZGF0YVxyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiBGRVRDSF9QVVJDSEFTRV9MT0dTLFxyXG4gICAgICBwYXlsb2FkOiByZXNwb25zZS5kYXRhLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHB1cmNoYXNlIGxvZ3M6JywgZXJyb3IubWVzc2FnZSk7ICAvLyBMb2cgYW55IGVycm9yIGR1cmluZyBmZXRjaGluZ1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiBIQU5ETEVfQVBJX0VSUk9SLFxyXG4gICAgICBwYXlsb2FkOiBlcnJvci5tZXNzYWdlLCAgLy8gUGFzcyBlcnJvciBtZXNzYWdlIHRvIHRoZSByZWR1Y2VyIGZvciBkaXNwbGF5XHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBBZGQgUHVyY2hhc2UgTG9nIEFjdGlvblxyXG5leHBvcnQgY29uc3QgYWRkUHVyY2hhc2VMb2cgPSAocHVyY2hhc2VEYXRhKSA9PiBhc3luYyAoZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgaXRlbU5hbWU6IHB1cmNoYXNlRGF0YS5pdGVtTmFtZT8udHJpbSgpLFxyXG4gICAgICBjYXRlZ29yeTogcHVyY2hhc2VEYXRhLmNhdGVnb3J5Py50cmltKCksXHJcbiAgICAgIHF1YW50aXR5OiBNYXRoLm1heCgxLCBOdW1iZXIocHVyY2hhc2VEYXRhLnF1YW50aXR5KSksXHJcbiAgICAgIHVuaXRQcmljZTogTWF0aC5tYXgoMCwgTnVtYmVyKHB1cmNoYXNlRGF0YS51bml0UHJpY2UpKSB8fCAwLFxyXG4gICAgICB0b3RhbENvc3Q6IE1hdGgubWF4KDAsIE51bWJlcihwdXJjaGFzZURhdGEucXVhbnRpdHkpICogTnVtYmVyKHB1cmNoYXNlRGF0YS51bml0UHJpY2UgfHwgMSkpLFxyXG4gICAgICBkYXRlOiBwdXJjaGFzZURhdGEuZGF0ZSB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIHN1cHBsaWVyOiBwdXJjaGFzZURhdGEuc3VwcGxpZXI/LnRyaW0oKSB8fCBudWxsLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnQWRkaW5nIHB1cmNoYXNlOicsIHBheWxvYWQpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL3B1cmNoYXNlcycsIHBheWxvYWQpO1xyXG5cclxuICAgIC8vIERpc3BhdGNoIHR3byBhY3Rpb25zOlxyXG4gICAgLy8gMS4gQWRkIHRoZSBuZXcgcHVyY2hhc2UgdG8gdGhlIGxvZ1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiBBRERfUFVSQ0hBU0VfTE9HLFxyXG4gICAgICBwYXlsb2FkOiByZXNwb25zZS5kYXRhLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gMi4gVXBkYXRlIHRoZSBpbnZlbnRvcnkgaXRlbSdzIHB1cmNoYXNlZCBxdWFudGl0eVxyXG4gICAgaWYgKHB1cmNoYXNlRGF0YS5pdGVtSWQpIHtcclxuICAgICAgZGlzcGF0Y2goe1xyXG4gICAgICAgIHR5cGU6IFVQREFURV9JVEVNLFxyXG4gICAgICAgIHBheWxvYWQ6IHtcclxuICAgICAgICAgIGlkOiBwdXJjaGFzZURhdGEuaXRlbUlkLFxyXG4gICAgICAgICAgdXBkYXRlczoge1xyXG4gICAgICAgICAgICBwdXJjaGFzZWQ6IHJlc3BvbnNlLmRhdGEubmV3UHVyY2hhc2VUb3RhbCwgLy8gWW91ciBBUEkgc2hvdWxkIHJldHVybiB0aGlzXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gaGFuZGxlQXBpRXJyb3IoZXJyb3IsIGRpc3BhdGNoLCBBRERfUFVSQ0hBU0VfTE9HKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZmV0Y2hVc2FnZSA9ICgpID0+IHtcclxuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjUwMDAvYXBpL3VzYWdlJyk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICB0eXBlOiAnRkVUQ0hfVVNBR0VfU1VDQ0VTUycsXHJcbiAgICAgICAgcGF5bG9hZDogZGF0YSxcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBkaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9VU0FHRV9GQUlMVVJFJywgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XHJcblxyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zb2xlLmxvZygnU2VsZWN0ZWQgSXRlbTonLCBzZWxlY3RlZEl0ZW0pO1xyXG5pZiAoc2VsZWN0ZWRJdGVtICYmIHNlbGVjdGVkSXRlbS5pZCkge1xyXG4gIGF3YWl0IGRpc3BhdGNoKFxyXG4gICAgdXBkYXRlSXRlbShzZWxlY3RlZEl0ZW0uaWQsIHtcclxuICAgICAgdXNlZDogc2VsZWN0ZWRJdGVtLnVzZWQgKyBwYXJzZUludChmb3JtRGF0YS5xdWFudGl0eVVzZWQpLFxyXG4gICAgfSlcclxuICApO1xyXG59IGVsc2Uge1xyXG4gIGNvbnNvbGUuZXJyb3IoJ1NlbGVjdGVkIGl0ZW0gSUQgaXMgdW5kZWZpbmVkIG9yIGludmFsaWQnKTtcclxufVxyXG4iXSwibmFtZXMiOlsiYXhpb3MiLCJBRERfSVRFTSIsIlVQREFURV9JVEVNIiwiREVMRVRFX0lURU0iLCJGRVRDSF9JVEVNUyIsIkZFVENIX1BVUkNIQVNFX0xPR1MiLCJIQU5ETEVfQVBJX0VSUk9SIiwiQUREX1BVUkNIQVNFX0xPRyIsIkFQSV9FUlJPUiIsIkFERF9VU0FHRSIsImFwaSIsImNyZWF0ZSIsImJhc2VVUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImhlYWRlcnMiLCJ2YWxpZGF0ZVN0YXR1cyIsInN0YXR1cyIsImhhbmRsZUFwaUVycm9yIiwiZXJyb3IiLCJkaXNwYXRjaCIsImFjdGlvblR5cGUiLCJlcnJvckRhdGEiLCJtZXNzYWdlIiwicmVzcG9uc2UiLCJkYXRhIiwiY29uc29sZSIsInR5cGUiLCJwYXlsb2FkIiwiYWRkSXRlbSIsIml0ZW0iLCJuYW1lIiwiY2F0ZWdvcnkiLCJFcnJvciIsInRyaW0iLCJpbml0aWFsU3RvY2siLCJNYXRoIiwibWF4IiwiTnVtYmVyIiwicHVyY2hhc2VkIiwidXNlZCIsImxvZyIsInBvc3QiLCJhZGRVc2FnZSIsInVzYWdlRGF0YSIsIml0ZW1OYW1lIiwicXVhbnRpdHlVc2VkIiwiZGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImFwcCIsInB1dCIsInJlcSIsInJlcyIsImlkIiwicGFyYW1zIiwiYm9keSIsInVwZGF0ZWRJdGVtIiwiSW52ZW50b3J5IiwiZmluZEJ5SWRBbmRVcGRhdGUiLCJuZXciLCJqc29uIiwiZGVsZXRlSXRlbSIsImRlbGV0ZSIsInN1Y2Nlc3MiLCJmZXRjaEl0ZW1zIiwiZ2V0IiwiZmV0Y2hQdXJjaGFzZUxvZ3MiLCJhZGRQdXJjaGFzZUxvZyIsInB1cmNoYXNlRGF0YSIsInF1YW50aXR5IiwidW5pdFByaWNlIiwidG90YWxDb3N0Iiwic3VwcGxpZXIiLCJpdGVtSWQiLCJ1cGRhdGVzIiwibmV3UHVyY2hhc2VUb3RhbCIsImZldGNoVXNhZ2UiLCJmZXRjaCIsInNlbGVjdGVkSXRlbSIsInVwZGF0ZUl0ZW0iLCJwYXJzZUludCIsImZvcm1EYXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/redux/actions.js\n"));

/***/ })

});