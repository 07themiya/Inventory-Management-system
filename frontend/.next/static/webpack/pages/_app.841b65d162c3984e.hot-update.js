"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "(pages-dir-browser)/./src/redux/actions.js":
/*!******************************!*\
  !*** ./src/redux/actions.js ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ADD_ITEM: () => (/* binding */ ADD_ITEM),\n/* harmony export */   ADD_PURCHASE_LOG: () => (/* binding */ ADD_PURCHASE_LOG),\n/* harmony export */   ADD_USAGE: () => (/* binding */ ADD_USAGE),\n/* harmony export */   API_ERROR: () => (/* binding */ API_ERROR),\n/* harmony export */   DELETE_ITEM: () => (/* binding */ DELETE_ITEM),\n/* harmony export */   FETCH_ITEMS: () => (/* binding */ FETCH_ITEMS),\n/* harmony export */   FETCH_PURCHASE_LOGS: () => (/* binding */ FETCH_PURCHASE_LOGS),\n/* harmony export */   HANDLE_API_ERROR: () => (/* binding */ HANDLE_API_ERROR),\n/* harmony export */   UPDATE_ITEM: () => (/* binding */ UPDATE_ITEM),\n/* harmony export */   addItem: () => (/* binding */ addItem),\n/* harmony export */   addPurchaseLog: () => (/* binding */ addPurchaseLog),\n/* harmony export */   addUsage: () => (/* binding */ addUsage),\n/* harmony export */   deleteItem: () => (/* binding */ deleteItem),\n/* harmony export */   fetchItems: () => (/* binding */ fetchItems),\n/* harmony export */   fetchPurchaseLogs: () => (/* binding */ fetchPurchaseLogs),\n/* harmony export */   fetchUsage: () => (/* binding */ fetchUsage),\n/* harmony export */   updateItem: () => (/* binding */ updateItem)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(pages-dir-browser)/./node_modules/axios/index.js\");\n\n// Action Types\nconst ADD_ITEM = 'ADD_ITEM';\nconst UPDATE_ITEM = 'UPDATE_ITEM';\nconst DELETE_ITEM = 'DELETE_ITEM';\nconst FETCH_ITEMS = 'FETCH_ITEMS';\nconst FETCH_PURCHASE_LOGS = 'FETCH_PURCHASE_LOGS';\nconst HANDLE_API_ERROR = 'HANDLE_API_ERROR';\nconst ADD_PURCHASE_LOG = 'ADD_PURCHASE_LOG';\nconst API_ERROR = 'API_ERROR';\nconst ADD_USAGE = 'ADD_USAGE';\n// Configure Axios instance with defaults\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: \"http://localhost:5000/api\" || 0,\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    validateStatus: function(status) {\n        return status < 500; // Don't throw for 4xx errors\n    }\n});\n// Helper function to handle API errors\nconst handleApiError = (error, dispatch1, actionType)=>{\n    var _error_response, _error_response1;\n    const errorData = {\n        message: error.message,\n        status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n        data: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.data,\n        actionType\n    };\n    console.error(\"API Error in \".concat(actionType, \":\"), errorData);\n    dispatch1({\n        type: API_ERROR,\n        payload: errorData\n    });\n    return errorData;\n};\n// Action Creators\n// Add Item Action\nconst addItem = (item)=>async (dispatch1)=>{\n        try {\n            if (!item.name || !item.category) {\n                throw new Error('Name and category are required');\n            }\n            const payload = {\n                name: item.name.trim(),\n                category: item.category.trim(),\n                initialStock: Math.max(0, Number(item.initialStock)) || 0,\n                purchased: Math.max(0, Number(item.purchased)) || 0,\n                used: Math.max(0, Number(item.used)) || 0\n            };\n            console.log('Adding item:', payload);\n            const response = await api.post('/inventory', payload);\n            dispatch1({\n                type: ADD_ITEM,\n                payload: response.data\n            });\n            return response.data;\n        } catch (error) {\n            return handleApiError(error, dispatch1, ADD_ITEM);\n        }\n    };\n// Add Usage Action\nconst addUsage = (usageData)=>async (dispatch1)=>{\n        try {\n            var _usageData_itemName, _usageData_category;\n            const payload = {\n                itemName: (_usageData_itemName = usageData.itemName) === null || _usageData_itemName === void 0 ? void 0 : _usageData_itemName.trim(),\n                category: (_usageData_category = usageData.category) === null || _usageData_category === void 0 ? void 0 : _usageData_category.trim(),\n                quantityUsed: Math.max(1, Number(usageData.quantityUsed)),\n                date: usageData.date || new Date().toISOString()\n            };\n            console.log('Adding usage:', payload);\n            const response = await api.post('/usage', payload);\n            dispatch1({\n                type: ADD_USAGE,\n                payload: response.data\n            });\n            return response.data;\n        } catch (error) {\n            return handleApiError(error, dispatch1, ADD_USAGE);\n        }\n    };\n// Update Item Action\nconst updateItem = (id, updates)=>async (dispatch1)=>{\n        try {\n            const payload = {\n                ...updates.name && {\n                    name: updates.name.trim()\n                },\n                ...updates.category && {\n                    category: updates.category.trim()\n                },\n                ...updates.initialStock && {\n                    initialStock: Math.max(0, Number(updates.initialStock))\n                },\n                ...updates.purchased && {\n                    purchased: Math.max(0, Number(updates.purchased))\n                },\n                ...updates.used && {\n                    used: Math.max(0, Number(updates.used))\n                }\n            };\n            console.log(\"Updating item \".concat(id, \":\"), payload);\n            const response = await api.put(\"/inventory/\".concat(id), payload);\n            dispatch1({\n                type: UPDATE_ITEM,\n                payload: {\n                    id,\n                    updates: response.data\n                }\n            });\n            return response.data;\n        } catch (error) {\n            return handleApiError(error, dispatch1, UPDATE_ITEM);\n        }\n    };\n// Delete Item Action\nconst deleteItem = (id)=>async (dispatch1)=>{\n        try {\n            console.log(\"Deleting item \".concat(id));\n            await api.delete(\"/inventory/\".concat(id));\n            dispatch1({\n                type: DELETE_ITEM,\n                payload: id\n            });\n            return {\n                success: true\n            };\n        } catch (error) {\n            return handleApiError(error, dispatch1, DELETE_ITEM);\n        }\n    };\n// Fetch Items Action\nconst fetchItems = ()=>async (dispatch1)=>{\n        try {\n            console.log('Fetching items');\n            const response = await api.get('/inventory');\n            dispatch1({\n                type: FETCH_ITEMS,\n                payload: response.data\n            });\n            return response.data;\n        } catch (error) {\n            return handleApiError(error, dispatch1, FETCH_ITEMS);\n        }\n    };\n// Fetch Purchase Logs Action\nconst fetchPurchaseLogs = ()=>async (dispatch1)=>{\n        try {\n            console.log('Fetching purchase logs');\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get('http://localhost:5000/api/purchases'); // Ensure correct backend URL\n            console.log(response.data); // Log the fetched data\n            dispatch1({\n                type: FETCH_PURCHASE_LOGS,\n                payload: response.data\n            });\n            return response.data;\n        } catch (error) {\n            console.error('Error fetching purchase logs:', error.message); // Log any error during fetching\n            dispatch1({\n                type: HANDLE_API_ERROR,\n                payload: error.message\n            });\n        }\n    };\n// Add Purchase Log Action\nconst addPurchaseLog = (purchaseData)=>async (dispatch1)=>{\n        try {\n            var _purchaseData_itemName, _purchaseData_category, _purchaseData_supplier;\n            const payload = {\n                itemName: (_purchaseData_itemName = purchaseData.itemName) === null || _purchaseData_itemName === void 0 ? void 0 : _purchaseData_itemName.trim(),\n                category: (_purchaseData_category = purchaseData.category) === null || _purchaseData_category === void 0 ? void 0 : _purchaseData_category.trim(),\n                quantity: Math.max(1, Number(purchaseData.quantity)),\n                unitPrice: Math.max(0, Number(purchaseData.unitPrice)) || 0,\n                totalCost: Math.max(0, Number(purchaseData.quantity) * Number(purchaseData.unitPrice || 1)),\n                date: purchaseData.date || new Date().toISOString(),\n                supplier: ((_purchaseData_supplier = purchaseData.supplier) === null || _purchaseData_supplier === void 0 ? void 0 : _purchaseData_supplier.trim()) || null\n            };\n            console.log('Adding purchase:', payload);\n            const response = await api.post('/purchases', payload);\n            // Dispatch two actions:\n            // 1. Add the new purchase to the log\n            dispatch1({\n                type: ADD_PURCHASE_LOG,\n                payload: response.data\n            });\n            // 2. Update the inventory item's purchased quantity\n            if (purchaseData.itemId) {\n                dispatch1({\n                    type: UPDATE_ITEM,\n                    payload: {\n                        id: purchaseData.itemId,\n                        updates: {\n                            purchased: response.data.newPurchaseTotal\n                        }\n                    }\n                });\n            }\n            return response.data;\n        } catch (error) {\n            return handleApiError(error, dispatch1, ADD_PURCHASE_LOG);\n        }\n    };\nconst fetchUsage = ()=>{\n    return async (dispatch1)=>{\n        try {\n            const response = await fetch('http://localhost:5000/api/usage');\n            const data = await response.json();\n            dispatch1({\n                type: 'FETCH_USAGE_SUCCESS',\n                payload: data\n            });\n        } catch (error) {\n            dispatch1({\n                type: 'FETCH_USAGE_FAILURE',\n                error: error.message\n            });\n        }\n    };\n};\nconsole.log('Selected Item:', selectedItem);\nif (selectedItem && selectedItem.id) {\n    await dispatch(updateItem(selectedItem.id, {\n        used: selectedItem.used + parseInt(formData.quantityUsed)\n    }));\n} else {\n    console.error('Selected item ID is undefined or invalid');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9yZWR1eC9hY3Rpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFFMUIsZUFBZTtBQUNSLE1BQU1DLFdBQVcsV0FBVztBQUM1QixNQUFNQyxjQUFjLGNBQWM7QUFDbEMsTUFBTUMsY0FBYyxjQUFjO0FBQ2xDLE1BQU1DLGNBQWMsY0FBYztBQUNsQyxNQUFNQyxzQkFBc0Isc0JBQXNCO0FBQ2xELE1BQU1DLG1CQUFtQixtQkFBbUI7QUFDNUMsTUFBTUMsbUJBQW1CLG1CQUFtQjtBQUM1QyxNQUFNQyxZQUFZLFlBQVk7QUFDOUIsTUFBTUMsWUFBWSxZQUFZO0FBRXJDLHlDQUF5QztBQUN6QyxNQUFNQyxNQUFNVixvREFBWSxDQUFDO0lBQ3ZCWSxTQUFTQywyQkFBK0IsSUFBSSxDQUEyQjtJQUN2RUcsU0FBUztRQUNQLGdCQUFnQjtJQUNsQjtJQUNBQyxnQkFBZ0IsU0FBVUMsTUFBTTtRQUM5QixPQUFPQSxTQUFTLEtBQUssNkJBQTZCO0lBQ3BEO0FBQ0Y7QUFFQSx1Q0FBdUM7QUFDdkMsTUFBTUMsaUJBQWlCLENBQUNDLE9BQU9DLFdBQVVDO1FBRzdCRixpQkFDRkE7SUFIUixNQUFNRyxZQUFZO1FBQ2hCQyxTQUFTSixNQUFNSSxPQUFPO1FBQ3RCTixNQUFNLEdBQUVFLGtCQUFBQSxNQUFNSyxRQUFRLGNBQWRMLHNDQUFBQSxnQkFBZ0JGLE1BQU07UUFDOUJRLElBQUksR0FBRU4sbUJBQUFBLE1BQU1LLFFBQVEsY0FBZEwsdUNBQUFBLGlCQUFnQk0sSUFBSTtRQUMxQko7SUFDRjtJQUVBSyxRQUFRUCxLQUFLLENBQUMsZ0JBQTJCLE9BQVhFLFlBQVcsTUFBSUM7SUFFN0NGLFVBQVM7UUFDUE8sTUFBTXBCO1FBQ05xQixTQUFTTjtJQUNYO0lBRUEsT0FBT0E7QUFDVDtBQUVBLGtCQUFrQjtBQUVsQixrQkFBa0I7QUFDWCxNQUFNTyxVQUFVLENBQUNDLE9BQVMsT0FBT1Y7UUFDdEMs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QW9EO1lBQ3BELElBQUlvQyxhQUFhSyxNQUFNLEVBQUU7Z0JBQ3ZCOUMsVUFBUztvQkFDUE8sTUFBTTFCO29CQUNOMkIsU0FBUzt3QkFDUHVCLElBQUlVLGFBQWFLLE1BQU07d0JBQ3ZCZCxTQUFTOzRCQUNQYixXQUFXZixTQUFTQyxJQUFJLENBQUMwQyxnQkFBZ0I7d0JBQzNDO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQSxPQUFPM0MsU0FBU0MsSUFBSTtRQUN0QixFQUFFLE9BQU9OLE9BQU87WUFDZCxPQUFPRCxlQUFlQyxPQUFPQyxXQUFVZDtRQUN6QztJQUNGLEVBQUU7QUFFSyxNQUFNOEQsYUFBYTtJQUN4QixPQUFPLE9BQU9oRDtRQUNaLElBQUk7WUFDRixNQUFNSSxXQUFXLE1BQU02QyxNQUFNO1lBQzdCLE1BQU01QyxPQUFPLE1BQU1ELFNBQVM4QyxJQUFJO1lBQ2hDbEQsVUFBUztnQkFDUE8sTUFBTTtnQkFDTkMsU0FBU0g7WUFDWDtRQUNGLEVBQUUsT0FBT04sT0FBTztZQUNkQyxVQUFTO2dCQUFFTyxNQUFNO2dCQUF1QlIsT0FBT0EsTUFBTUksT0FBTztZQUFDO1FBRS9EO0lBQ0Y7QUFDRixFQUFFO0FBRUZHLFFBQVFlLEdBQUcsQ0FBQyxrQkFBa0I4QjtBQUM5QixJQUFJQSxnQkFBZ0JBLGFBQWFwQixFQUFFLEVBQUU7SUFDbkMsTUFBTS9CLFNBQ0o4QixXQUFXcUIsYUFBYXBCLEVBQUUsRUFBRTtRQUMxQlgsTUFBTStCLGFBQWEvQixJQUFJLEdBQUdnQyxTQUFTQyxTQUFTM0IsWUFBWTtJQUMxRDtBQUVKLE9BQU87SUFDTHBCLFFBQVFQLEtBQUssQ0FBQztBQUNoQiIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxJbnZlbnRvcnkgTWFuYWdlbWVudCBzeXN0ZW1cXGZyb250ZW5kXFxzcmNcXHJlZHV4XFxhY3Rpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcblxyXG4vLyBBY3Rpb24gVHlwZXNcclxuZXhwb3J0IGNvbnN0IEFERF9JVEVNID0gJ0FERF9JVEVNJztcclxuZXhwb3J0IGNvbnN0IFVQREFURV9JVEVNID0gJ1VQREFURV9JVEVNJztcclxuZXhwb3J0IGNvbnN0IERFTEVURV9JVEVNID0gJ0RFTEVURV9JVEVNJztcclxuZXhwb3J0IGNvbnN0IEZFVENIX0lURU1TID0gJ0ZFVENIX0lURU1TJztcclxuZXhwb3J0IGNvbnN0IEZFVENIX1BVUkNIQVNFX0xPR1MgPSAnRkVUQ0hfUFVSQ0hBU0VfTE9HUyc7XHJcbmV4cG9ydCBjb25zdCBIQU5ETEVfQVBJX0VSUk9SID0gJ0hBTkRMRV9BUElfRVJST1InO1xyXG5leHBvcnQgY29uc3QgQUREX1BVUkNIQVNFX0xPRyA9ICdBRERfUFVSQ0hBU0VfTE9HJztcclxuZXhwb3J0IGNvbnN0IEFQSV9FUlJPUiA9ICdBUElfRVJST1InO1xyXG5leHBvcnQgY29uc3QgQUREX1VTQUdFID0gJ0FERF9VU0FHRSc7XHJcblxyXG4vLyBDb25maWd1cmUgQXhpb3MgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0c1xyXG5jb25zdCBhcGkgPSBheGlvcy5jcmVhdGUoe1xyXG4gIGJhc2VVUkw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9hcGknLFxyXG4gIGhlYWRlcnM6IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgfSxcclxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gKHN0YXR1cykge1xyXG4gICAgcmV0dXJuIHN0YXR1cyA8IDUwMDsgLy8gRG9uJ3QgdGhyb3cgZm9yIDR4eCBlcnJvcnNcclxuICB9LFxyXG59KTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgQVBJIGVycm9yc1xyXG5jb25zdCBoYW5kbGVBcGlFcnJvciA9IChlcnJvciwgZGlzcGF0Y2gsIGFjdGlvblR5cGUpID0+IHtcclxuICBjb25zdCBlcnJvckRhdGEgPSB7XHJcbiAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgc3RhdHVzOiBlcnJvci5yZXNwb25zZT8uc3RhdHVzLFxyXG4gICAgZGF0YTogZXJyb3IucmVzcG9uc2U/LmRhdGEsXHJcbiAgICBhY3Rpb25UeXBlLFxyXG4gIH07XHJcblxyXG4gIGNvbnNvbGUuZXJyb3IoYEFQSSBFcnJvciBpbiAke2FjdGlvblR5cGV9OmAsIGVycm9yRGF0YSk7XHJcblxyXG4gIGRpc3BhdGNoKHtcclxuICAgIHR5cGU6IEFQSV9FUlJPUixcclxuICAgIHBheWxvYWQ6IGVycm9yRGF0YSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGVycm9yRGF0YTtcclxufTtcclxuXHJcbi8vIEFjdGlvbiBDcmVhdG9yc1xyXG5cclxuLy8gQWRkIEl0ZW0gQWN0aW9uXHJcbmV4cG9ydCBjb25zdCBhZGRJdGVtID0gKGl0ZW0pID0+IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIWl0ZW0ubmFtZSB8fCAhaXRlbS5jYXRlZ29yeSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWUgYW5kIGNhdGVnb3J5IGFyZSByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgIG5hbWU6IGl0ZW0ubmFtZS50cmltKCksXHJcbiAgICAgIGNhdGVnb3J5OiBpdGVtLmNhdGVnb3J5LnRyaW0oKSxcclxuICAgICAgaW5pdGlhbFN0b2NrOiBNYXRoLm1heCgwLCBOdW1iZXIoaXRlbS5pbml0aWFsU3RvY2spKSB8fCAwLFxyXG4gICAgICBwdXJjaGFzZWQ6IE1hdGgubWF4KDAsIE51bWJlcihpdGVtLnB1cmNoYXNlZCkpIHx8IDAsXHJcbiAgICAgIHVzZWQ6IE1hdGgubWF4KDAsIE51bWJlcihpdGVtLnVzZWQpKSB8fCAwLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnQWRkaW5nIGl0ZW06JywgcGF5bG9hZCk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvaW52ZW50b3J5JywgcGF5bG9hZCk7XHJcblxyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiBBRERfSVRFTSxcclxuICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gaGFuZGxlQXBpRXJyb3IoZXJyb3IsIGRpc3BhdGNoLCBBRERfSVRFTSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gQWRkIFVzYWdlIEFjdGlvblxyXG5leHBvcnQgY29uc3QgYWRkVXNhZ2UgPSAodXNhZ2VEYXRhKSA9PiBhc3luYyAoZGlzcGF0Y2gpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgaXRlbU5hbWU6IHVzYWdlRGF0YS5pdGVtTmFtZT8udHJpbSgpLFxyXG4gICAgICBjYXRlZ29yeTogdXNhZ2VEYXRhLmNhdGVnb3J5Py50cmltKCksXHJcbiAgICAgIHF1YW50aXR5VXNlZDogTWF0aC5tYXgoMSwgTnVtYmVyKHVzYWdlRGF0YS5xdWFudGl0eVVzZWQpKSxcclxuICAgICAgZGF0ZTogdXNhZ2VEYXRhLmRhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnQWRkaW5nIHVzYWdlOicsIHBheWxvYWQpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL3VzYWdlJywgcGF5bG9hZCk7XHJcblxyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiBBRERfVVNBR0UsXHJcbiAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuIGhhbmRsZUFwaUVycm9yKGVycm9yLCBkaXNwYXRjaCwgQUREX1VTQUdFKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBVcGRhdGUgSXRlbSBBY3Rpb25cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUl0ZW0gPSAoaWQsIHVwZGF0ZXMpID0+IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAuLi4odXBkYXRlcy5uYW1lICYmIHsgbmFtZTogdXBkYXRlcy5uYW1lLnRyaW0oKSB9KSxcclxuICAgICAgLi4uKHVwZGF0ZXMuY2F0ZWdvcnkgJiYgeyBjYXRlZ29yeTogdXBkYXRlcy5jYXRlZ29yeS50cmltKCkgfSksXHJcbiAgICAgIC4uLih1cGRhdGVzLmluaXRpYWxTdG9jayAmJiB7IGluaXRpYWxTdG9jazogTWF0aC5tYXgoMCwgTnVtYmVyKHVwZGF0ZXMuaW5pdGlhbFN0b2NrKSkgfSksXHJcbiAgICAgIC4uLih1cGRhdGVzLnB1cmNoYXNlZCAmJiB7IHB1cmNoYXNlZDogTWF0aC5tYXgoMCwgTnVtYmVyKHVwZGF0ZXMucHVyY2hhc2VkKSkgfSksXHJcbiAgICAgIC4uLih1cGRhdGVzLnVzZWQgJiYgeyB1c2VkOiBNYXRoLm1heCgwLCBOdW1iZXIodXBkYXRlcy51c2VkKSkgfSksXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyBpdGVtICR7aWR9OmAsIHBheWxvYWQpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucHV0KGAvaW52ZW50b3J5LyR7aWR9YCwgcGF5bG9hZCk7XHJcblxyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiBVUERBVEVfSVRFTSxcclxuICAgICAgcGF5bG9hZDogeyBpZCwgdXBkYXRlczogcmVzcG9uc2UuZGF0YSB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiBoYW5kbGVBcGlFcnJvcihlcnJvciwgZGlzcGF0Y2gsIFVQREFURV9JVEVNKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBEZWxldGUgSXRlbSBBY3Rpb25cclxuZXhwb3J0IGNvbnN0IGRlbGV0ZUl0ZW0gPSAoaWQpID0+IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgRGVsZXRpbmcgaXRlbSAke2lkfWApO1xyXG4gICAgYXdhaXQgYXBpLmRlbGV0ZShgL2ludmVudG9yeS8ke2lkfWApO1xyXG5cclxuICAgIGRpc3BhdGNoKHtcclxuICAgICAgdHlwZTogREVMRVRFX0lURU0sXHJcbiAgICAgIHBheWxvYWQ6IGlkLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gaGFuZGxlQXBpRXJyb3IoZXJyb3IsIGRpc3BhdGNoLCBERUxFVEVfSVRFTSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRmV0Y2ggSXRlbXMgQWN0aW9uXHJcbmV4cG9ydCBjb25zdCBmZXRjaEl0ZW1zID0gKCkgPT4gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBpdGVtcycpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkuZ2V0KCcvaW52ZW50b3J5Jyk7XHJcblxyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiBGRVRDSF9JVEVNUyxcclxuICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gaGFuZGxlQXBpRXJyb3IoZXJyb3IsIGRpc3BhdGNoLCBGRVRDSF9JVEVNUyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRmV0Y2ggUHVyY2hhc2UgTG9ncyBBY3Rpb25cclxuZXhwb3J0IGNvbnN0IGZldGNoUHVyY2hhc2VMb2dzID0gKCkgPT4gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBwdXJjaGFzZSBsb2dzJyk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldCgnaHR0cDovL2xvY2FsaG9zdDo1MDAwL2FwaS9wdXJjaGFzZXMnKTsgIC8vIEVuc3VyZSBjb3JyZWN0IGJhY2tlbmQgVVJMXHJcblxyXG4gICAgY29uc29sZS5sb2cocmVzcG9uc2UuZGF0YSk7IC8vIExvZyB0aGUgZmV0Y2hlZCBkYXRhXHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6IEZFVENIX1BVUkNIQVNFX0xPR1MsXHJcbiAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHVyY2hhc2UgbG9nczonLCBlcnJvci5tZXNzYWdlKTsgIC8vIExvZyBhbnkgZXJyb3IgZHVyaW5nIGZldGNoaW5nXHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6IEhBTkRMRV9BUElfRVJST1IsXHJcbiAgICAgIHBheWxvYWQ6IGVycm9yLm1lc3NhZ2UsICAvLyBQYXNzIGVycm9yIG1lc3NhZ2UgdG8gdGhlIHJlZHVjZXIgZm9yIGRpc3BsYXlcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEFkZCBQdXJjaGFzZSBMb2cgQWN0aW9uXHJcbmV4cG9ydCBjb25zdCBhZGRQdXJjaGFzZUxvZyA9IChwdXJjaGFzZURhdGEpID0+IGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICBpdGVtTmFtZTogcHVyY2hhc2VEYXRhLml0ZW1OYW1lPy50cmltKCksXHJcbiAgICAgIGNhdGVnb3J5OiBwdXJjaGFzZURhdGEuY2F0ZWdvcnk/LnRyaW0oKSxcclxuICAgICAgcXVhbnRpdHk6IE1hdGgubWF4KDEsIE51bWJlcihwdXJjaGFzZURhdGEucXVhbnRpdHkpKSxcclxuICAgICAgdW5pdFByaWNlOiBNYXRoLm1heCgwLCBOdW1iZXIocHVyY2hhc2VEYXRhLnVuaXRQcmljZSkpIHx8IDAsXHJcbiAgICAgIHRvdGFsQ29zdDogTWF0aC5tYXgoMCwgTnVtYmVyKHB1cmNoYXNlRGF0YS5xdWFudGl0eSkgKiBOdW1iZXIocHVyY2hhc2VEYXRhLnVuaXRQcmljZSB8fCAxKSksXHJcbiAgICAgIGRhdGU6IHB1cmNoYXNlRGF0YS5kYXRlIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgc3VwcGxpZXI6IHB1cmNoYXNlRGF0YS5zdXBwbGllcj8udHJpbSgpIHx8IG51bGwsXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgcHVyY2hhc2U6JywgcGF5bG9hZCk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvcHVyY2hhc2VzJywgcGF5bG9hZCk7XHJcblxyXG4gICAgLy8gRGlzcGF0Y2ggdHdvIGFjdGlvbnM6XHJcbiAgICAvLyAxLiBBZGQgdGhlIG5ldyBwdXJjaGFzZSB0byB0aGUgbG9nXHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6IEFERF9QVVJDSEFTRV9MT0csXHJcbiAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAyLiBVcGRhdGUgdGhlIGludmVudG9yeSBpdGVtJ3MgcHVyY2hhc2VkIHF1YW50aXR5XHJcbiAgICBpZiAocHVyY2hhc2VEYXRhLml0ZW1JZCkge1xyXG4gICAgICBkaXNwYXRjaCh7XHJcbiAgICAgICAgdHlwZTogVVBEQVRFX0lURU0sXHJcbiAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgaWQ6IHB1cmNoYXNlRGF0YS5pdGVtSWQsXHJcbiAgICAgICAgICB1cGRhdGVzOiB7XHJcbiAgICAgICAgICAgIHB1cmNoYXNlZDogcmVzcG9uc2UuZGF0YS5uZXdQdXJjaGFzZVRvdGFsLCAvLyBZb3VyIEFQSSBzaG91bGQgcmV0dXJuIHRoaXNcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHJldHVybiBoYW5kbGVBcGlFcnJvcihlcnJvciwgZGlzcGF0Y2gsIEFERF9QVVJDSEFTRV9MT0cpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmZXRjaFVzYWdlID0gKCkgPT4ge1xyXG4gIHJldHVybiBhc3luYyAoZGlzcGF0Y2gpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9hcGkvdXNhZ2UnKTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgZGlzcGF0Y2goe1xyXG4gICAgICAgIHR5cGU6ICdGRVRDSF9VU0FHRV9TVUNDRVNTJyxcclxuICAgICAgICBwYXlsb2FkOiBkYXRhLFxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0ZFVENIX1VTQUdFX0ZBSUxVUkUnLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcclxuXHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnNvbGUubG9nKCdTZWxlY3RlZCBJdGVtOicsIHNlbGVjdGVkSXRlbSk7XHJcbmlmIChzZWxlY3RlZEl0ZW0gJiYgc2VsZWN0ZWRJdGVtLmlkKSB7XHJcbiAgYXdhaXQgZGlzcGF0Y2goXHJcbiAgICB1cGRhdGVJdGVtKHNlbGVjdGVkSXRlbS5pZCwge1xyXG4gICAgICB1c2VkOiBzZWxlY3RlZEl0ZW0udXNlZCArIHBhcnNlSW50KGZvcm1EYXRhLnF1YW50aXR5VXNlZCksXHJcbiAgICB9KVxyXG4gICk7XHJcbn0gZWxzZSB7XHJcbiAgY29uc29sZS5lcnJvcignU2VsZWN0ZWQgaXRlbSBJRCBpcyB1bmRlZmluZWQgb3IgaW52YWxpZCcpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJheGlvcyIsIkFERF9JVEVNIiwiVVBEQVRFX0lURU0iLCJERUxFVEVfSVRFTSIsIkZFVENIX0lURU1TIiwiRkVUQ0hfUFVSQ0hBU0VfTE9HUyIsIkhBTkRMRV9BUElfRVJST1IiLCJBRERfUFVSQ0hBU0VfTE9HIiwiQVBJX0VSUk9SIiwiQUREX1VTQUdFIiwiYXBpIiwiY3JlYXRlIiwiYmFzZVVSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiaGVhZGVycyIsInZhbGlkYXRlU3RhdHVzIiwic3RhdHVzIiwiaGFuZGxlQXBpRXJyb3IiLCJlcnJvciIsImRpc3BhdGNoIiwiYWN0aW9uVHlwZSIsImVycm9yRGF0YSIsIm1lc3NhZ2UiLCJyZXNwb25zZSIsImRhdGEiLCJjb25zb2xlIiwidHlwZSIsInBheWxvYWQiLCJhZGRJdGVtIiwiaXRlbSIsIm5hbWUiLCJjYXRlZ29yeSIsIkVycm9yIiwidHJpbSIsImluaXRpYWxTdG9jayIsIk1hdGgiLCJtYXgiLCJOdW1iZXIiLCJwdXJjaGFzZWQiLCJ1c2VkIiwibG9nIiwicG9zdCIsImFkZFVzYWdlIiwidXNhZ2VEYXRhIiwiaXRlbU5hbWUiLCJxdWFudGl0eVVzZWQiLCJkYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlSXRlbSIsImlkIiwidXBkYXRlcyIsInB1dCIsImRlbGV0ZUl0ZW0iLCJkZWxldGUiLCJzdWNjZXNzIiwiZmV0Y2hJdGVtcyIsImdldCIsImZldGNoUHVyY2hhc2VMb2dzIiwiYWRkUHVyY2hhc2VMb2ciLCJwdXJjaGFzZURhdGEiLCJxdWFudGl0eSIsInVuaXRQcmljZSIsInRvdGFsQ29zdCIsInN1cHBsaWVyIiwiaXRlbUlkIiwibmV3UHVyY2hhc2VUb3RhbCIsImZldGNoVXNhZ2UiLCJmZXRjaCIsImpzb24iLCJzZWxlY3RlZEl0ZW0iLCJwYXJzZUludCIsImZvcm1EYXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/redux/actions.js\n"));

/***/ })

});